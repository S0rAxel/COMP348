
(defun sub-list (l from &optional (to nil))
    (cond 
        ((null l) nil)
        ((<= from 0) nil)
        ((< 1 from) 
            (if (null to)
                (sub-list (cdr l) (- from 1))
                (sub-list (cdr l) (- from 1) (- to 1))
            ))
        ((null to) l)
        ((< (length l) to) nil)
        ((< 0 to) 
			(cons (car l) (sub-list (cdr l) from (- to 1))))
    )
)

; (print (sub-list '(5 6 7 8 9 1) 4 3))
(print (sub-list '(1 4 10 8 9 1) 2 3)) ; output: (4 10)
(print (sub-list '(1 4 10 8 9 1) 2 ))  ; output: (4 10 8 9 1)
(print (sub-list '(1 4 10 8 9 1) 2 7)) ; output: NIL
(print (sub-list '(1 4 10 8 9 1) 1 4)) ; output: (1 4 10 8)
(print (sub-list '(1 4 10 8 9 1) 0 1)) ; output: NIL
(print (sub-list '(1 4 10 8 9 1) 4 2)) ; output: NIL
(print (sub-list '(1 4 10 8 9 1) 2 6)) ; output: (4 10 8 9 1)

(defun sub-list2 (l from &optional (to nil))
	    (cond 
        ((null l) nil)
        ((<= from 0) (sub-list2 l 1 to))
        ((< 1 from) 
            (if (null to)
                (sub-list2 (cdr l) (- from 1))
                (sub-list2 (cdr l) (- from 1) (- to 1))
            ))
        ((null to) l)
        ((< 0 to) 
			(cons (car l) (sub-list2 (cdr l) from (- to 1))))
    )
)

(print (sub-list2 '(1 4 10 8 9 1) 2 3)) ; output: (4 10)
(print (sub-list2 '(1 4 10 8 9 1) 2))   ; output: (4 10 8 9 1)   
(print (sub-list2 '(1 4 10 8 9 1) 2 7)) ; output: (4 10 8 9 1)     
(print (sub-list2 '(1 4 10 8 9 1) 1 4)) ; output: (1 4 10 8)
(print (sub-list2 '(1 4 10 8 9 1) 0 1)) ; output: (1)
(print (sub-list2 '(1 4 10 8 9 1) -1))  ; output: (1 4 10 8 9 1)
(print (sub-list2 '(1 4 10 8 9 1) 4 2)) ; output: NIL

(defun sub-list3 (l from &optional (to nil))
	 (if (and (not to) (< from to))
		(cond 
        ((null l) nil)
        ((<= from 0) (sub-list3 l 1 to))
        ((< 1 from) 
            (if (null to)
                (sub-list3 (cdr l) (- from 1))
                (sub-list3 (cdr l) (- from 1) (- to 1))
            ))
        ((null to) l)
        ((< 0 to) 
			(cons (car l) (sub-list3 (cdr l) from (- to 1))))
		)
	 )
)

(defun flatten-nums-nodup (l) 
	(cond
		((null l) nil)
        ((member (car l) l) (flatten-nums-nodup (cdr l)))
        ((atom l)
            (if (numberp (car l))
                (cons (car l) (flatten-nums-nodup (cdr l)))
                (flatten-nums-nodup (cdr l))
            )
         )
        ((listp (car l)) (mapcan #'flatten-nums-nodup l))
	)
)

(print (flatten-nums-nodup '(1 2 (3 1) (a 2.5) (2 4.5) ((1 2)))))

;A)
(defun tribonacci-seqA (n)
    (cond
        ((zerop n) nil)
        ((<= n 2) 0)
        ((= n 3) 1)
        (t (let (value)
                (dotimes (i n value)
                    (setq value (cons (+ (- n 1) (- n 2) (- n 3)) value))
                )
            )
        )
    )
)

(print (tribonacci-seqA 7)) ; output: 7,   expected: (0 0 1 1 2 4 7)
(print (tribonacci-seqA 0)) ; output: nil
(print (tribonacci-seqA 1)) ; output: 0

;B) 
(defun tribonacci-seqB (n)
    (cond 
        ((zerop n) nil)
        ((<= n 2) 0)
        ((= n 3) 1)
        (t (+ (tribonacci-seqB (- n 1)) (tribonacci-seqB (- n 2)) (tribonacci-seqB (- n 3))))
    )
)

(print (tribonacci-seqB 7)) ; output: 7,   expected: (0 0 1 1 2 4 7)
(print (tribonacci-seqB 0)) ; output: nil
(print (tribonacci-seqB 1)) ; output: 0

(defun depth (e)
	(cond
        ((atom (cdr e)) 0)
        ((listp e) 
           (+ 1 (apply #'max (mapcar #'depth e))) ; (mapcar #'depth e)))
        )
    ) 
)

(print (depth nil)) 			 ; output: 0
(print (depth 1))				 ; output: 0 
(print (depth '(1)))             ; output: 1
(print (depth '((2))))           ; output: 2 
(print (depth '((2)(3 (6))(4)))) ; output: 3